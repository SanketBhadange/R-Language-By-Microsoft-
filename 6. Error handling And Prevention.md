# Error Handling and Error Prevention


You’re reviewing an extensive order report from a supplier when suddenly, your script breaks. A column meant to hold prices has a few entries marked "free," one marked "N/A," and a missing value.

Errors like these are common, especially when working with customer records, sales transactions, survey responses, or medical readings. If you don’t catch them early, your script might produce the wrong totals or fail. 

That’s why it’s essential to build in simple checks for:

- Missing values

- Incorrect types (like text where numbers are expected)

- Inputs that don’t match your expectations

In this reading, you’ll learn how to detect missing values using any(), and confirm that data is numeric with is.numeric (), and write “not” conditions using the"!" symbol. These quick-to-learn tools are essential for writing dependable R code.

## Checking for Missing Values with any()
You’re supporting an environmental science team analyzing daily air quality readings. On some days, sensors didn’t transmit any values, so those missing entries show up in R as NA.

To keep calculations accurate, you need to check if any readings are missing before continuing:

Air-Quality Missing-Value Check
```R
readings <- c(52, 48, NA, 56)

if (any(is.na(readings))) {
  print("Warning: Data contains missing values.")
}
```
What’s happening here?

- is.na(readings) checks each value: is it NA?

- any() returns TRUE if even one value is missing

- The if statement uses that result to trigger a clear warning

### Try It Yourself: Detecting Missing Data in Healthcare
You’re working in a hospital’s data department. Every morning, your team pulls temperature readings from bedside sensors. Today, a nurse flags that one of the reports didn’t load correctly, and you're tasked with checking if the temperature data has any missing values before analysis.

### Your task:

Write a function called check_patient_data()

Inside the function:

Use any(is.na(...)) to check if any readings are missing

Return a message: "Missing data found" if any NAs are present

Otherwise, return "All patient readings present."

Run your function with this starter code:

Check-Patient-Data Function – Starter
```R
# Define the function
check_patient_data <- function(readings) {
  # Step 1: Use is.na() to check for NA values
  # Step 2: Wrap that check in any() to scan the full vector
  # Step 3: If any values are missing, return "Missing data found"
  # Step 4: Otherwise, return "All patient readings present"

  # Your code goes here:
  if (any(is.na(readings))) {
    
    return("Missing data found")
  } else {
    
    return("All patient readings present.")
  }
}
# Task 5: Test your function
temp_readings <- c(98.6, 99.1, NA, 98.9, 97.5)
check_patient_data(temp_readings)
```
What should happen:

If your function is working correctly, the test input should return:

[1] "Missing data found"

Your final code should look like this:

Check-Patient-Data Function – Solution
```R
check_patient_data <- function(readings) {
  if (any(is.na(readings))) {
    return("Missing data found")
  }
  return("All patient readings present")
}

check_patient_data(temp_readings)
```
### What’s happening here?

- is.na(readings) checks each entry, if there are any that are NA

- any() returns TRUE if at least one value is NA

- The if statement runs when there's missing data

You found out that the temperature data did include missing values. This confirmed the nurse’s concern and helped you flag the issue early before it could affect patient reports.

### Common Issues and Fixes:

- Forgot to use any()? Remember: is.na() checks each item—any() tells if any are missing.

- Getting all the values printed? You might be missing a return() statement.

- Nothing happens? Make sure to call your function after defining it!

## Confirming Numeric Input with is.numeric()
You’re helping your company’s finance team build a tool that calculates discounts. One of your inputs is amount_paid. But instead of a number, someone entered "twenty," and now the script won’t run.

To prevent this kind of error, you can confirm that the input is numeric before using it in a calculation:

Amount-Paid Numeric-Validation
```R
# A value is entered as text, not a number
amount_paid <- "twenty"

# Check if the value is not numeric
if (!is.numeric(amount_paid)) {
  # If it's not numeric, show a clear error message
  print("Error: Amount must be a number.")
}
```
### What’s happening here?

- This function checks whether a value is stored as a number in R.

- It returns TRUE if the value is numeric and FALSE if not.

- The ! symbol flips the result. So if amount_paid is not numeric, the message gets printed.

### Try It Yourself: Confirming Numeric Payment Input in Retail
You’re supporting a retail company’s payment processing team. Today, a transaction failed due to an input error: instead of typing 100, a customer accidentally typed "1O0"—using the letter O instead of zero. You need to ensure that inputs are numeric before continuing calculations.

Your task:

- Write a function called validate_payment()

- Inside the function:

Check if the input is numeric using is.numeric()

If it’s not numeric, return: "Input must be numeric"

Otherwise, return: "Input looks good"

Run your function with this starter code:

Validate-Payment Function– Starter
```R
# Starter Code: Validating numeric payment input
payment_amount <- "1O0"  # O instead of 0 could break calculations

# Step 1: Use is.numeric() to check the type
# Step 2: Use ! to check if it's not numeric
# Step 3: If not numeric, return an error message
# Step 4: Otherwise, return a confirmation

validate_payment <- function(x) {
  # Your code goes here:
  if (!is.numeric(x)) {
    
    return("Input must be numeric")
  } else {
    
    return("Input looks good")
  }

# Step 5: Test your function
validate_payment(payment_amount)
```
### What should happen:

If your function is working correctly, the test input should return:

[1] "Input must be numeric"

 ### Your final code should look like this:

Validate-Payment Function– Solution
```R
validate_payment <- function(x) {
  if (!is.numeric(x)) {
    return("Input must be numeric")
  }
  return("Input looks good")
}

validate_payment(payment_amount)
```
### What’s happening here?

- is.numeric(x) checks if the value is numeric

- !is.numeric(x) means "not numeric"—it returns TRUE when the value is not a number

You discovered that the payment value "1O0" was not truly numeric. Your function correctly flagged the issue, preventing a bad input from affecting payment calculations.

### Common Issues and Fixes:

- Used is.numeric() alone? Add ! to check if it's NOT numeric.

- Have no output? Make sure you called validate_payment(...) at the end.

- Did you use the incorrect variable? Double-check you're passing the correct value (amount_paid).

## Bringing It Together
You work for a city’s transit authority. Each month, you receive ridership data from bus lines across the city. But sometimes the number of riders is missing, or entered incorrectly, such as using the letter "O" instead of the digit zero.

Before summarizing the data, you need to verify that it's usable. Here's a function designed to do just that:

Validate-Ridership Data Function– Full Checks
```R
validate_ridership <- function(data) {
  if (!is.numeric(data)) {
    return("Ridership data must be numeric.")
  }
  if (any(is.na(data))) {
    return("Ridership data contains missing values.")
  }
  return("Ridership data is ready to use.")
}
```
### What’s happening here?

- is.numeric(data) checks whether the input is stored as a number.

- !is.numeric(data) means "the input is NOT numeric". The exclamation mark "!" reverses the result, meaning the input is numeric (TRUE)," ! "makes it FALSE, and vice versa.

- any(is.na(data)) checks if any values are missing. If even one is NA, the function returns a warning.

- Only if both checks pass does the function confirm the data is ready.

### Wrap Up
You’ve now seen how to:

Spot missing values with any(is.na(...))

Check if something is a number using is.numeric()

Use ! to reverse a check when you want to say “only run this if not…”

These small checks go a long way. They help keep your code clear, your data clean, and your results trustworthy.
